(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{52:function(t,s,a){"use strict";a.r(s);var n=a(0),o=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 队列")]),a("p",[t._v("队列的本质是一个数组，但只能从队尾添加元素，从队首移除元素。这保证了第一个入队的元素总是第一个出队。先到先得！")]),a("p",[t._v("有什么使用场景呢? 比如我们排队买票,总要设置一个公平的规则,让先来的人先得到票.在很多算法的实现中，你可能需要将某些对象放到一个临时的列表中，之后再将其取出。通常加入和取出元素的顺序非常重要。")]),a("p",[t._v("队列和栈有些不一样,队列可以保证元素存入和取出的顺序是先进先出(first-in first-out, FIFO)的，第一个入队的元素总是第一个出队，公平合理！栈，它是一个后进先出(last-in, first-out, LIFO)的结构。")]),a("p",[t._v("下面用swift来实现一个基本的队列.")]),a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[t._v("\n"),a("span",{attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{attrs:{class:"token builtin"}},[t._v("Queue")]),a("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" array "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("T"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{attrs:{class:"token comment"}},[t._v("//  入队列")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("mutating")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("enqueue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token number"}},[t._v("_")]),t._v(" element"),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" T"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("append")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("element"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{attrs:{class:"token comment"}},[t._v("//  出队列")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("mutating")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("dequeue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" T"),a("span",{attrs:{class:"token operator"}},[t._v("?")]),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("isEmpty")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{attrs:{class:"token constant"}},[t._v("nil")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("removeFirst")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{attrs:{class:"token comment"}},[t._v("//  获取队列首元素")]),t._v("\n    "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("peek")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" T"),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("first")]),t._v("\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])]),a("p",[t._v("上面实现的队列只是可以正常工作，入队操作的时间复杂度为 O(1)，因为在数组的尾部添加元素只需要固定的时间，跟数组的大小无关.因为在 Swift 的内部实现中，数组的尾部总是有一些预设的空间可供使用.举个例子:")]),a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[t._v("\t"),a("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" queue "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token builtin"}},[t._v("Queue")]),a("span",{attrs:{class:"token operator"}},[t._v("<")]),a("span",{attrs:{class:"token builtin"}},[t._v("String")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tqueue"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("enqueue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v('"a"')]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tqueue"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("enqueue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v('"b"')]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tqueue"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("enqueue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v('"c"')]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),a("p",[t._v("我们向队列插入若干条数据,实际上数组的空间可能是下面这个样子的:")]),a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[t._v("\t"),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{attrs:{class:"token string"}},[t._v('"a"')]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{attrs:{class:"token string"}},[t._v('"b"')]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{attrs:{class:"token string"}},[t._v('"c"')]),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{attrs:{class:"token string"}},[t._v('"xxx"')]),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),a("p",[t._v("xxx代表已经申请,但是还未使用的内存,再尾部插入一个元素就会使用到这个未被使用的内存.所以,简单的拷贝内存的工作，只需要固定的常量时间.")]),a("p",[t._v("当然，数组尾部的未使用内存的大小是有限的，如果最后一块未使用内存也被占用的时候，再添加元素会使得数组重新调整大小来获取更多的空间,这时候,重新调整的过程包括申请新的内存，将已有数据迁移到新内存中,这个操作的时间复杂度是 O(n).实际开发过程中,这种情况并不常见，所以，这个操作的时间复杂度依然是 O(1) 的，或者说是近似 O(1) 的.")]),a("p",[t._v("但是出队列的操作是将数组头部元素移除,以为这回导致内存移位的操作,所以这个操作时间复杂度是O(n).")]),a("h3",{attrs:{id:"一个更加高效的队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个更加高效的队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 一个更加高效的队列")]),a("p",[t._v("为了让队列的出列更加高效,我们可以使用入队类似的技巧,也就是在"),a("strong",[t._v("队首")]),t._v("保留一些额外的内存空间,因为swift并没有提供这种机制,所以我们要手动修改一下:")]),a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[t._v("\t"),a("span",{attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{attrs:{class:"token builtin"}},[t._v("FastQueue")]),a("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" array "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("T"),a("span",{attrs:{class:"token operator"}},[t._v("?")]),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" head "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("0")]),t._v("\n\t    \n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("mutating")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("enqueue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token number"}},[t._v("_")]),t._v(" element"),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" T"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t        array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("append")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("element"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("mutating")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("dequeue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" T"),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t        "),a("span",{attrs:{class:"token keyword"}},[t._v("guard")]),t._v(" head "),a("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("count")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("let")]),t._v(" element "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("head"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t            "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{attrs:{class:"token constant"}},[t._v("nil")]),t._v("\n\t        "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t        array"),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("head"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token constant"}},[t._v("nil")]),t._v("\n\t        head "),a("span",{attrs:{class:"token operator"}},[t._v("+")]),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("1")]),t._v("\n\t        "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" element\n\t    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t    \n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("peek")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" T"),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t        "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("isEmpty")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{attrs:{class:"token constant"}},[t._v("nil")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("head"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\t    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),a("p",[t._v("上述代码简单的实现了一个出队列不操作内存移位,而用空值来进行头部的占位.\n针对 "),a("code",[t._v("dequeue()")]),t._v(" 函数，在将队首元素出队时，我们首先将 "),a("code",[t._v("array[head]")]),t._v(" 设置为 "),a("code",[t._v("nil")]),t._v(" 来将这个元素从数组中移除。然后将 "),a("code",[t._v("head")]),t._v(" 的值加一，使得下一个元素变成新的队首。")]),a("p",[t._v("但是,如果我们从不移除队首的空位，随着不断地入队和出队，队列所占空间将不断增长。为了周期性地清理无用空间,我们将上面的代码再优化一下:")]),a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[t._v("\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("mutating")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("dequeue")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" T"),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{attrs:{class:"token keyword"}},[t._v("guard")]),t._v(" head "),a("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("count")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("let")]),t._v(" element "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("head"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{attrs:{class:"token constant"}},[t._v("nil")]),t._v("\n        "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        array"),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("head"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token constant"}},[t._v("nil")]),t._v("\n        head "),a("span",{attrs:{class:"token operator"}},[t._v("+")]),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("1")]),t._v("\n        \n        "),a("span",{attrs:{class:"token keyword"}},[t._v("let")]),t._v(" capacity "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("50")]),t._v("   "),a("span",{attrs:{class:"token comment"}},[t._v("//数组的容量")]),t._v("\n        "),a("span",{attrs:{class:"token keyword"}},[t._v("let")]),t._v(" persect "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("0.2")]),t._v("   "),a("span",{attrs:{class:"token comment"}},[t._v("//阈值")]),t._v("\n        \n        "),a("span",{attrs:{class:"token comment"}},[t._v("//  数组容量过大,或超过头部所占空间的阈值 , 使用原始出列方式以节约空间")]),t._v("\n        "),a("span",{attrs:{class:"token keyword"}},[t._v("if")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("count")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" capacity "),a("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("Double")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("head"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("Double")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("count")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" persect "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("removeFirst")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            head "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("0")]),t._v("\n        "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" element\n    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),a("p",[t._v("当队列的数组超过我们设定的阈值,我们将使用原始的方式移除首部元素,以重新排列内存,因为移除的操作并不会很频繁,所以现在出队操作的复杂度已经从当初的 O(n) 变为了现在的 O(1).")])])}],!1,null,null,null);s.default=o.exports}}]);