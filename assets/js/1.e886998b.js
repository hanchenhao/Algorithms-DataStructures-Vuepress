(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{50:function(t,s,a){"use strict";a.r(s);var n=a(0),o=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"栈-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack","aria-hidden":"true"}},[t._v("#")]),t._v(" 栈(stack)")]),a("p",[t._v("栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为"),a("strong",[t._v("栈顶")]),t._v("，相对地，把另一端称为"),a("strong",[t._v("栈底")]),t._v("。向一个栈插入新元素又称作"),a("strong",[t._v("进栈")]),t._v("、"),a("strong",[t._v("入栈")]),t._v("或"),a("strong",[t._v("压栈")]),t._v("，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。")]),a("p",[t._v("栈的设计有什么实际的使用场景呢?可以想象一下大学上课的时候,我总是最后来到教室,而最先离开教室😁这个时候,我来到教室就可以称为入栈(push),离开就是出栈(pop),老师想知道谁来的最晚,就可以通过peek找到我,并将我赶出教室/(ㄒoㄒ)/~~.")]),a("p",[t._v("栈可以保证元素存入和取出的顺序是后进先出(last-in first-out, LIFO)的.栈中弹出的元素总是你最后放进去的那个.另外一个非常类似的数据结构是"),a("strong",[t._v("队列")]),t._v("，它是一个先进先出(first-in, first-out, FIFO)的结构.")]),a("p",[t._v("下面用swift来实现一个基本的栈。只需要包装一下数组，将存取功能限制为 pop、push 和 peek 即可.")]),a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[t._v("\n\t"),a("span",{attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{attrs:{class:"token builtin"}},[t._v("Stack")]),a("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{attrs:{class:"token comment"}},[t._v("//  创建一个数组")]),t._v("\n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("var")]),t._v(" array "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("[")]),t._v("T"),a("span",{attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t    "),a("span",{attrs:{class:"token comment"}},[t._v("//  入栈,将元素插入数组末端")]),t._v("\n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("mutating")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("push")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token number"}},[t._v("_")]),t._v(" element"),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" T"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{attrs:{class:"token builtin"}},[t._v("Void")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t        array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("append")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("element"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t    "),a("span",{attrs:{class:"token comment"}},[t._v("//  出栈,将数组的末端元素移除")]),t._v("\n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("mutating")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("pop")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" T"),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t        "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("isEmpty")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v("  "),a("span",{attrs:{class:"token constant"}},[t._v("nil")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("removeLast")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t    "),a("span",{attrs:{class:"token comment"}},[t._v("//  获取栈顶元素")]),t._v("\n\t    "),a("span",{attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{attrs:{class:"token function"}},[t._v("peek")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("-")]),a("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v(" T"),a("span",{attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t        "),a("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" array"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token builtin"}},[t._v("last")]),t._v("\n\t    "),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t    \n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),a("p",[t._v("压栈(push)操作是将新元素压入数组的尾部，而不是头部。在数组的头部插入元素是一个很耗时的操作，它的时间复杂度为 O(n)，因为需要将现有元素往后移位为新元素腾出空间。而在尾部插入元素的时间复杂度为 O(1)；无论数组有多少元素，这个操作所消耗的时间都是一个常量。")]),a("p",[t._v("每次调用函数或方法，CPU 都会将函数返回地址压入到运行栈中。当这个函数执行结束的时候，CPU 将返回地址从栈中取出，并据此返回到函数被调用的位置。所以，如果不断地调用太多的函数(例如死递归函数)，就会得到一个所谓的“栈溢出(stack overflow)” 错误，因为 CPU 运行栈没有空间了。")])])}],!1,null,null,null);s.default=o.exports}}]);